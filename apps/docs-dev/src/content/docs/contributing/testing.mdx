---
title: Testing
description: Testing requirements and guidelines
---

## Overview

All contributions should include appropriate tests. We use:

- **Vitest** for unit tests
- **Convex Testing** for integration tests
- **Playwright** for E2E tests

## Unit Tests

Test isolated logic and components:

```typescript
// src/lib/calculateXP.test.ts
import { describe, it, expect } from "vitest";
import { calculateXP } from "./calculateXP";

describe("calculateXP", () => {
  it("awards base XP for win", () => {
    expect(calculateXP({ win: true, duration: 300 })).toBe(100);
  });

  it("awards bonus XP for quick win", () => {
    expect(calculateXP({ win: true, duration: 120 })).toBe(150);
  });

  it("awards reduced XP for loss", () => {
    expect(calculateXP({ win: false, duration: 300 })).toBe(25);
  });
});
```

**Run unit tests:**

```bash
bun run test:unit
bun run test:unit -- --watch  # Watch mode
```

## Integration Tests

Test Convex functions with a real backend:

```typescript
// convex/__tests__/gameplay.test.ts
import { describe, it, expect, beforeEach } from "vitest";
import { convexTest } from "convex-test";
import { api } from "../_generated/api";

describe("Game Flow", () => {
  const t = convexTest();

  beforeEach(async () => {
    await t.run(async (ctx) => {
      // Seed test data
    });
  });

  it("allows players to join game", async () => {
    const result = await t.mutation(api.gameplay.lobby.join, {
      lobbyId: testLobbyId,
      deckId: testDeckId,
    });

    expect(result.success).toBe(true);
  });

  it("starts game when both players ready", async () => {
    const gameId = await t.mutation(api.gameplay.lobby.startGame, {
      lobbyId: testLobbyId,
    });

    const game = await t.query(api.gameplay.games.get, { gameId });

    expect(game.status).toBe("active");
    expect(game.currentTurn).toBe(1);
  });
});
```

**Run integration tests:**

```bash
bun run test:integration
```

## E2E Tests

Test complete user flows:

```typescript
// e2e/game-flow.spec.ts
import { test, expect } from "@playwright/test";

test("user can create and play game", async ({ page }) => {
  // Login
  await page.goto("/");
  await page.click("text=Login");
  await page.fill('input[type="email"]', "test@example.com");
  await page.click("button:has-text('Sign In')");

  // Create game
  await page.click("text=New Game");
  await page.waitForURL("/game/*");

  // Verify game started
  await expect(page.locator("text=Your Turn")).toBeVisible();
});
```

**Run E2E tests:**

```bash
bun run test:e2e
bun run test:e2e:ui  # Interactive mode
```

## Test Coverage

| Area | Coverage Target |
|------|-----------------|
| Game logic | 90%+ |
| Effect system | 95%+ |
| API functions | 80%+ |
| UI components | 70%+ |

## Writing Good Tests

### Do

- Test behavior, not implementation
- Use descriptive test names
- Test edge cases
- Keep tests focused (one assertion per test when possible)
- Use factories for test data

### Don't

- Test internal implementation details
- Write brittle tests that break on refactors
- Skip error case testing
- Leave flaky tests

## Test Data Factories

Use factories for consistent test data:

```typescript
// e2e/setup/factories.ts
export const createTestUser = (overrides = {}) => ({
  username: `test-${Date.now()}`,
  email: `test-${Date.now()}@example.com`,
  ...overrides,
});

export const createTestDeck = (overrides = {}) => ({
  name: "Test Deck",
  cards: generateValidDeck(),
  ...overrides,
});
```

---

## Related

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Code Style"
    description="Coding standards"
    href="/contributing/code-style/"
  />
  <LinkCard
    title="Pull Requests"
    description="PR process"
    href="/contributing/pull-requests/"
  />
</CardGrid>
