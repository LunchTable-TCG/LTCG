---
title: Security
description: Security practices for LunchTable TCG
---

import { Aside, Steps } from '@astrojs/starlight/components';

## Overview

Security is critical for a multiplayer game with real value (cards, currency). This guide covers our security practices.

## Authentication

### Clerk Integration

All authentication flows through Clerk:

```typescript
// convex/lib/auth.ts
export async function requireAuth(ctx: QueryCtx | MutationCtx) {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) {
    throw new Error("Unauthorized");
  }
  return identity;
}

export async function requireUser(ctx: QueryCtx | MutationCtx) {
  const identity = await requireAuth(ctx);
  const user = await ctx.db
    .query("users")
    .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
    .unique();

  if (!user) {
    throw new Error("User not found");
  }
  return user;
}
```

### Session Security

- Sessions expire after 7 days of inactivity
- Refresh tokens rotate on each use
- Sessions are invalidated on password change

## Authorization

### Row-Level Security

Every database query enforces ownership:

```typescript
export const getUserDecks = query({
  args: {},
  handler: async (ctx) => {
    const user = await requireUser(ctx);

    // Only return decks owned by the authenticated user
    return ctx.db
      .query("decks")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .collect();
  },
});
```

### Game State Validation

<Aside type="caution">
  Never trust client-provided game state. Always validate on the server.
</Aside>

```typescript
export const playCard = mutation({
  args: {
    gameId: v.id("games"),
    cardInstanceId: v.string(),
  },
  handler: async (ctx, { gameId, cardInstanceId }) => {
    const user = await requireUser(ctx);
    const game = await ctx.db.get(gameId);

    // Validate player is in this game
    if (game.player1.playerId !== user._id && game.player2.playerId !== user._id) {
      throw new Error("Not a player in this game");
    }

    // Validate it's their turn
    const isPlayer1 = game.player1.playerId === user._id;
    if ((isPlayer1 && game.activePlayer !== 1) || (!isPlayer1 && game.activePlayer !== 2)) {
      throw new Error("Not your turn");
    }

    // Validate card is in their hand
    const playerState = isPlayer1 ? game.player1 : game.player2;
    if (!playerState.hand.some((c) => c.instanceId === cardInstanceId)) {
      throw new Error("Card not in hand");
    }

    // ... proceed with validated action
  },
});
```

## Hidden Information

### Card Visibility

Players should never see:
- Opponent's hand contents
- Deck order (either player)
- Face-down trap cards

```typescript
export const getGame = query({
  args: { gameId: v.id("games") },
  handler: async (ctx, { gameId }) => {
    const user = await requireUser(ctx);
    const game = await ctx.db.get(gameId);

    const isPlayer1 = game.player1.playerId === user._id;
    const isPlayer2 = game.player2.playerId === user._id;
    const isSpectator = !isPlayer1 && !isPlayer2;

    return {
      ...game,
      player1: {
        ...game.player1,
        // Hide opponent's hand
        hand: isPlayer1 ? game.player1.hand : game.player1.hand.map(hideCard),
        // Never expose deck contents
        deck: game.player1.deck.length,
        // Hide face-down traps
        field: game.player1.field.map((c) =>
          c.faceDown && !isPlayer1 ? hideCard(c) : c
        ),
      },
      player2: {
        ...game.player2,
        hand: isPlayer2 ? game.player2.hand : game.player2.hand.map(hideCard),
        deck: game.player2.deck.length,
        field: game.player2.field.map((c) =>
          c.faceDown && !isPlayer2 ? hideCard(c) : c
        ),
      },
    };
  },
});
```

## Input Validation

### Argument Validation

Use Convex validators for all inputs:

```typescript
export const createDeck = mutation({
  args: {
    name: v.string(),
    cards: v.array(v.id("cards")),
  },
  handler: async (ctx, { name, cards }) => {
    // Additional validation
    if (name.length < 1 || name.length > 50) {
      throw new Error("Deck name must be 1-50 characters");
    }

    if (cards.length < 30 || cards.length > 60) {
      throw new Error("Deck must have 30-60 cards");
    }

    // Validate all cards exist
    for (const cardId of cards) {
      const card = await ctx.db.get(cardId);
      if (!card) {
        throw new Error(`Invalid card: ${cardId}`);
      }
    }

    // ... create deck
  },
});
```

### Rate Limiting

Prevent abuse with rate limits:

```typescript
// convex/lib/rateLimit.ts
export async function checkRateLimit(
  ctx: MutationCtx,
  userId: Id<"users">,
  action: string,
  limit: number,
  windowMs: number
) {
  const windowStart = Date.now() - windowMs;

  const recentActions = await ctx.db
    .query("rateLimits")
    .withIndex("by_user_action", (q) =>
      q.eq("userId", userId).eq("action", action)
    )
    .filter((q) => q.gte(q.field("timestamp"), windowStart))
    .collect();

  if (recentActions.length >= limit) {
    throw new Error("Rate limit exceeded. Please try again later.");
  }

  await ctx.db.insert("rateLimits", {
    userId,
    action,
    timestamp: Date.now(),
  });
}
```

## Anti-Cheat Measures

### Server Authority

<Aside type="tip">
  The server is always the source of truth. Clients only send intents.
</Aside>

```typescript
// Client sends intent
const result = await playCard({ gameId, cardInstanceId });

// Server validates and executes
// - Verifies it's player's turn
// - Verifies card is in hand
// - Verifies player has enough mana
// - Calculates all effects
// - Updates authoritative state
```

### Action Logging

Log all game actions for review:

```typescript
await ctx.db.insert("gameActions", {
  gameId,
  playerId: user._id,
  action: "playCard",
  data: { cardInstanceId },
  timestamp: Date.now(),
});
```

### Suspicious Activity Detection

```typescript
// Flag unusual patterns
if (playerWinRate > 0.95 && gamesPlayed > 20) {
  await flagForReview(playerId, "Unusually high win rate");
}

if (averageTurnTime < 500) {
  // < 500ms per turn
  await flagForReview(playerId, "Suspiciously fast play");
}
```

## Environment Security

### Secret Management

<Steps>

1. **Never commit secrets**

   ```bash
   # .gitignore
   .env
   .env.local
   .env.*.local
   ```

2. **Use environment variables**

   ```bash
   # Set in Vercel/Convex dashboards
   CLERK_SECRET_KEY=sk_live_...
   ```

3. **Rotate secrets regularly**

   - API keys: Every 90 days
   - Webhook secrets: Every 90 days
   - Database credentials: Every 180 days

</Steps>

### Dependency Security

```bash
# Check for vulnerabilities
bun audit

# Update dependencies
bun update
```

## Incident Response

### If a Security Issue is Found

1. **Assess** - Determine scope and severity
2. **Contain** - Disable affected features if necessary
3. **Fix** - Deploy patches
4. **Notify** - Inform affected users if data was compromised
5. **Review** - Post-mortem and prevention measures

### Contact

Report security issues to: security@ltcg.io

---

## Related

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Deployment"
    description="Deployment guide"
    href="/operations/deployment/"
  />
  <LinkCard
    title="Monitoring"
    description="Production monitoring"
    href="/operations/monitoring/"
  />
</CardGrid>
