---
title: Game Engine
description: Understanding the LunchTable TCG game engine
---

import { Aside } from '@astrojs/starlight/components';

## Overview

The LunchTable TCG game engine manages the entire game flow, from lobby creation to victory conditions.

## Game Flow

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   LOBBY     │ ──► │   ACTIVE    │ ──► │   ENDED     │
│  (waiting)  │     │  (playing)  │     │ (complete)  │
└─────────────┘     └─────────────┘     └─────────────┘
       │                   │
       ▼                   ▼
    Players            Turn Loop
     Join              (see below)
```

## Turn Loop

Each turn follows a strict phase order:

```
┌───────────────────────────────────────────────────────┐
│                     TURN START                         │
│         (Untap creatures, refresh mana)               │
└────────────────────────┬──────────────────────────────┘
                         ▼
┌───────────────────────────────────────────────────────┐
│                    DRAW PHASE                          │
│              (Draw 1 card from deck)                  │
└────────────────────────┬──────────────────────────────┘
                         ▼
┌───────────────────────────────────────────────────────┐
│                   MAIN PHASE 1                         │
│     (Play cards, summon creatures, set traps)         │
└────────────────────────┬──────────────────────────────┘
                         ▼
┌───────────────────────────────────────────────────────┐
│                   BATTLE PHASE                         │
│    (Declare attacks, resolve combat, triggers)        │
└────────────────────────┬──────────────────────────────┘
                         ▼
┌───────────────────────────────────────────────────────┐
│                   MAIN PHASE 2                         │
│          (Additional plays after combat)              │
└────────────────────────┬──────────────────────────────┘
                         ▼
┌───────────────────────────────────────────────────────┐
│                    END PHASE                           │
│        (Discard to hand limit, end triggers)          │
└────────────────────────┬──────────────────────────────┘
                         ▼
                   NEXT PLAYER
```

## Game State

The game state is a single source of truth stored in Convex:

```typescript
interface GameState {
  // Meta
  _id: Id<"games">;
  status: "active" | "ended";

  // Turn tracking
  currentTurn: number;
  currentPhase: TurnPhase;
  activePlayerId: Id<"users">;

  // Players
  player1: PlayerState;
  player2: PlayerState;

  // Effect processing
  effectStack: Effect[];
  pendingTriggers: Trigger[];

  // History
  turnHistory: TurnAction[];
}

interface PlayerState {
  playerId: Id<"users">;
  lifePoints: number;
  mana: number;
  maxMana: number;

  // Zones
  deck: CardInstance[];       // Face down
  hand: CardInstance[];       // Private
  field: (CardInstance | null)[]; // 4 slots
  traps: (CardInstance | null)[]; // 3 slots
  graveyard: CardInstance[];  // Public
}
```

## Action Processing

Every action follows the same pipeline:

```typescript
async function processAction(
  ctx: MutationCtx,
  gameId: Id<"games">,
  action: GameAction
) {
  // 1. Load current state
  const game = await ctx.db.get(gameId);

  // 2. Validate action
  const validation = validateAction(game, action);
  if (!validation.valid) {
    throw new Error(validation.error);
  }

  // 3. Apply action
  const result = applyAction(game, action);

  // 4. Process triggered effects
  const triggers = collectTriggers(game, action, result);
  await processEffectStack(ctx, game, triggers);

  // 5. Check win conditions
  const winner = checkWinConditions(game);
  if (winner) {
    game.status = "ended";
    game.winnerId = winner;
  }

  // 6. Save updated state
  await ctx.db.replace(gameId, game);

  return result;
}
```

## Combat System

Combat resolution follows these steps:

```typescript
function resolveCombat(
  attacker: CardInstance,
  defender: CardInstance | "direct"
): CombatResult {
  if (defender === "direct") {
    // Direct attack to player
    return {
      damage: attacker.currentAttack,
      target: "player"
    };
  }

  // Creature combat
  const attackerDamage = calculateDamage(attacker, defender);
  const defenderDamage = calculateDamage(defender, attacker);

  // Apply element modifiers
  const modifiedAttackerDamage = applyElementModifier(
    attackerDamage,
    attacker.element,
    defender.element
  );

  return {
    attackerDamage: modifiedAttackerDamage,
    defenderDamage,
    attackerDestroyed: defenderDamage >= attacker.currentHealth,
    defenderDestroyed: modifiedAttackerDamage >= defender.currentHealth
  };
}
```

## Element Advantages

```typescript
const ELEMENT_CHART: Record<Element, Element[]> = {
  ember: ["nature"],    // Ember beats Nature
  frost: ["ember"],     // Frost beats Ember
  nature: ["frost"],    // Nature beats Frost
  arcane: ["void"],     // Arcane beats Void
  void: ["neutral"],    // Void beats Neutral
  neutral: []           // Neutral has no advantages
};

const DAMAGE_MODIFIER = 1.5; // 50% bonus damage

function hasElementAdvantage(attacker: Element, defender: Element): boolean {
  return ELEMENT_CHART[attacker].includes(defender);
}
```

<Aside type="note">
  Element advantage grants a 50% damage bonus, not an automatic win.
</Aside>

## Win Conditions

The game checks for victory after every action:

```typescript
function checkWinConditions(game: GameState): Id<"users"> | null {
  // Life Points reduced to 0
  if (game.player1.lifePoints <= 0) return game.player2.playerId;
  if (game.player2.lifePoints <= 0) return game.player1.playerId;

  // Deck out (can't draw when required)
  // Handled during draw phase

  // Special card effects
  // Handled by effect system

  return null;
}
```

---

## Related

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Effect System"
    description="How card abilities work"
    href="/architecture/effect-system/"
  />
  <LinkCard
    title="Real-time Updates"
    description="Sync across clients"
    href="/architecture/realtime/"
  />
</CardGrid>
