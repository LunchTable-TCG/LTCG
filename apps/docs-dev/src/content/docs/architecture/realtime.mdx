---
title: Real-time Updates
description: How LunchTable TCG keeps clients in sync
---

## Overview

LunchTable TCG uses Convex's real-time subscriptions to keep all clients synchronized automatically.

## How It Works

```
┌─────────────────────────────────────────────────────────┐
│                    CONVEX BACKEND                        │
│  ┌─────────────┐     ┌─────────────┐                   │
│  │  Mutations  │ ──► │  Database   │                   │
│  └─────────────┘     └──────┬──────┘                   │
│                             │                           │
│                    ┌────────┴────────┐                 │
│                    │  Subscriptions  │                 │
│                    └───────┬┬┬───────┘                 │
└────────────────────────────┼┼┼──────────────────────────┘
                             │││
          ┌──────────────────┴┴┴──────────────────┐
          │                  │                     │
          ▼                  ▼                     ▼
   ┌──────────┐       ┌──────────┐         ┌──────────┐
   │ Client 1 │       │ Client 2 │         │ Client N │
   │ (Player) │       │ (Player) │         │(Spectator)│
   └──────────┘       └──────────┘         └──────────┘
```

## Query Subscriptions

Convex queries automatically update when their dependencies change:

```typescript
// This hook subscribes to the game state
// It automatically updates when any mutation modifies the game
function GameBoard({ gameId }: { gameId: Id<"games"> }) {
  const game = useQuery(api.gameplay.games.get, { gameId });

  // game updates automatically when:
  // - Opponent plays a card
  // - Combat resolves
  // - Effects trigger
  // - Turns change

  return <BoardRenderer game={game} />;
}
```

## Optimistic Updates

For better UX, use optimistic updates for immediate feedback:

```typescript
const playCard = useMutation(api.gameplay.turns.playCard);

async function handlePlayCard(cardId: string) {
  // Optimistically update local state
  setLocalState(prev => ({
    ...prev,
    hand: prev.hand.filter(c => c.id !== cardId)
  }));

  try {
    await playCard({ gameId, cardInstanceId: cardId });
    // Server state will sync automatically
  } catch (error) {
    // Revert on error
    setLocalState(prev => ({
      ...prev,
      hand: [...prev.hand, getCard(cardId)]
    }));
  }
}
```

## Hidden Information

Games have hidden information that must be protected:

```typescript
// Query that returns game state with visibility rules
export const getGame = query({
  args: { gameId: v.id("games") },
  handler: async (ctx, { gameId }) => {
    const game = await ctx.db.get(gameId);
    const userId = await ctx.auth.getUserIdentity();

    // Determine what this user can see
    const isPlayer1 = game.player1.playerId === userId?.subject;
    const isPlayer2 = game.player2.playerId === userId?.subject;

    return {
      ...game,
      player1: {
        ...game.player1,
        // Hide opponent's hand
        hand: isPlayer1 ? game.player1.hand : game.player1.hand.map(hideCard),
        // Hide deck contents
        deck: game.player1.deck.length,
      },
      player2: {
        ...game.player2,
        hand: isPlayer2 ? game.player2.hand : game.player2.hand.map(hideCard),
        deck: game.player2.deck.length,
      },
    };
  },
});

function hideCard(card: CardInstance): HiddenCard {
  return { id: card.id, hidden: true };
}
```

## Presence

Track online status and activity:

```typescript
// presence.ts
export const heartbeat = mutation({
  args: { gameId: v.id("games") },
  handler: async (ctx, { gameId }) => {
    const userId = await requireAuth(ctx);

    await ctx.db.patch(gameId, {
      [`presence.${userId}`]: Date.now()
    });
  },
});

// Client sends heartbeat every 10 seconds
useEffect(() => {
  const interval = setInterval(() => {
    heartbeat({ gameId });
  }, 10000);

  return () => clearInterval(interval);
}, [gameId]);
```

## Reconnection

Handle disconnections gracefully:

```typescript
function useGameConnection(gameId: Id<"games">) {
  const [isConnected, setIsConnected] = useState(true);

  useEffect(() => {
    const client = getConvexClient();

    client.onConnectionChange((connected) => {
      setIsConnected(connected);

      if (connected) {
        // Reconnected - state will sync automatically
        toast.success("Reconnected to game");
      } else {
        toast.warning("Connection lost. Reconnecting...");
      }
    });
  }, []);

  return { isConnected };
}
```

---

## Related

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Game Engine"
    description="Game state management"
    href="/architecture/game-engine/"
  />
  <LinkCard
    title="Effect System"
    description="Processing effects"
    href="/architecture/effect-system/"
  />
</CardGrid>
