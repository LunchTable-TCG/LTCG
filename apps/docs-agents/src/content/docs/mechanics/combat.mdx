---
title: Combat
description: Combat mechanics and damage calculation
---

import { Aside } from '@astrojs/starlight/components';

## Combat Overview

Combat is how you deal damage to your opponent and remove their creatures. Understanding combat mechanics is essential for making optimal attack decisions.

## Combat Phases

```
┌─────────────────────────────────────────────────────────────┐
│                     COMBAT PHASE                             │
├────────────────┬─────────────────┬──────────────────────────┤
│ Declare        │ Declare         │ Damage                   │
│ Attackers      │ Blockers        │ Resolution               │
│ (You)          │ (Opponent)      │ (Automatic)              │
├────────────────┼─────────────────┼──────────────────────────┤
│ Choose which   │ Opponent        │ Combat damage dealt      │
│ creatures      │ chooses         │ simultaneously.          │
│ attack and     │ blockers.       │ Destroyed creatures      │
│ their targets. │                 │ go to graveyard.         │
└────────────────┴─────────────────┴──────────────────────────┘
```

## Declaring Attacks

### Attack Targets

Creatures can attack:
- **Opponent directly** - Deals damage to opponent's life points
- **Enemy creatures** - Trades damage with the target

```typescript
// Direct attack (opponent has no Taunt creatures)
await runtime.executeAction('ATTACK', {
  attackerId: 'my_creature_01',
  targetId: 'opponent',
});

// Attack a creature
await runtime.executeAction('ATTACK', {
  attackerId: 'my_creature_01',
  targetId: 'enemy_creature_01',
});
```

### Attack Restrictions

Not all creatures can attack:

| Restriction | Description |
|-------------|-------------|
| Summoning sickness | Creature was summoned this turn (unless Rush) |
| Already attacked | Creature attacked this turn |
| Tapped | Creature is tapped |
| Frozen | Effect preventing attacks |
| Pacified | Effect preventing attacks |

```typescript
// Check if creature can attack
function canAttack(creature: Creature, state: GameState): boolean {
  if (creature.hasSummoningSickness && !creature.keywords.includes('Rush')) {
    return false;
  }
  if (creature.hasAttacked) return false;
  if (creature.isTapped) return false;
  if (creature.debuffs.some(d => d.type === 'frozen' || d.type === 'pacified')) {
    return false;
  }
  return true;
}
```

---

## Taunt Mechanic

Creatures with Taunt must be attacked before other targets.

**Rules:**
- If opponent has any Taunt creatures, you must attack them
- Cannot attack opponent directly while Taunt creatures exist
- Cannot attack non-Taunt creatures while Taunt creatures exist

```typescript
function getValidTargets(attacker: Creature, state: GameState): string[] {
  const enemyField = state.opponent.field;
  const tauntCreatures = enemyField.filter(c => c.keywords.includes('Taunt'));

  if (tauntCreatures.length > 0) {
    // Must attack Taunt creatures
    return tauntCreatures.map(c => c.id);
  }

  // Can attack any creature or opponent directly
  return [...enemyField.map(c => c.id), 'opponent'];
}
```

<Aside type="tip" title="Taunt Removal">
  Removing or silencing Taunt creatures opens up direct attacks. Prioritize dealing with Taunt before going for lethal.
</Aside>

---

## Damage Calculation

### Basic Combat

When a creature attacks another creature:

```typescript
interface CombatResult {
  attackerDamage: number;   // Damage attacker deals
  defenderDamage: number;   // Damage defender deals (counter-attack)
  attackerDies: boolean;
  defenderDies: boolean;
}

function calculateCombat(attacker: Creature, defender: Creature): CombatResult {
  const attackerDamage = attacker.attack;
  const defenderDamage = defender.attack;

  return {
    attackerDamage,
    defenderDamage,
    attackerDies: defenderDamage >= attacker.health,
    defenderDies: attackerDamage >= defender.health,
  };
}
```

### Keyword Modifiers

Keywords modify combat:

| Keyword | Effect |
|---------|--------|
| **Deathtouch** | Any damage kills the target |
| **First Strike** | Deals damage first; if target dies, no counter |
| **Double Strike** | Deals damage in first strike AND normal timing |
| **Lifesteal** | Heals owner for damage dealt |
| **Shield** | First damage instance is prevented |
| **Trample** | Excess damage goes to opponent |

```typescript
function calculateCombatWithKeywords(
  attacker: Creature,
  defender: Creature,
  state: GameState
): CombatResult {
  let attackerDamage = attacker.attack;
  let defenderDamage = defender.attack;
  let attackerHealth = attacker.health;
  let defenderHealth = defender.health;

  // Shield blocks first damage
  if (defender.keywords.includes('Shield')) {
    attackerDamage = 0; // First hit absorbed
    // Remove shield buff
  }

  // Deathtouch
  if (attacker.keywords.includes('Deathtouch') && attackerDamage > 0) {
    defenderHealth = 0; // Instant kill
  }
  if (defender.keywords.includes('Deathtouch') && defenderDamage > 0) {
    attackerHealth = 0;
  }

  // First Strike
  if (attacker.keywords.includes('First Strike')) {
    // Attacker deals damage first
    defenderHealth -= attackerDamage;
    if (defenderHealth <= 0) {
      defenderDamage = 0; // Dead creature can't counter
    }
  }

  // ... resolve remaining damage

  return result;
}
```

---

## Direct Attacks

When attacking the opponent directly:

```typescript
function attackOpponent(attacker: Creature, state: GameState): number {
  let damage = attacker.attack;

  // Trample still applies (no defender to "absorb")
  // Lifesteal heals
  if (attacker.keywords.includes('Lifesteal')) {
    state.self.lifePoints += damage;
  }

  state.opponent.lifePoints -= damage;
  return damage;
}
```

---

## Combat Tricks

### Pre-Combat Buffs

Cast buffs before declaring attacks:

```typescript
async function buffAndAttack(runtime: Runtime) {
  const hand = await handProvider.get(runtime);
  const state = await gameStateProvider.get(runtime);

  // Find buff spells
  const buffSpells = hand.cards.filter(
    c => c.type === 'spell' && c.effect.includes('+')
  );

  // Cast buff on strongest attacker
  const bestAttacker = state.self.field
    .filter(c => canAttack(c, state))
    .sort((a, b) => b.attack - a.attack)[0];

  if (buffSpells.length > 0 && bestAttacker) {
    await runtime.executeAction('ACTIVATE_SPELL', {
      cardId: buffSpells[0].id,
      targets: [bestAttacker.id],
    });
  }

  // Now attack with buffed creature
  await runtime.executeAction('ATTACK', {
    attackerId: bestAttacker.id,
    targetId: 'opponent',
  });
}
```

### Combat Math

Always calculate before attacking:

```typescript
function evaluateAttack(
  attacker: Creature,
  target: Creature | 'opponent',
  state: GameState
): number {
  if (target === 'opponent') {
    // Direct damage value
    return attacker.attack * 2; // High priority
  }

  const combat = calculateCombatWithKeywords(attacker, target, state);

  // Trade evaluation
  let value = 0;

  if (combat.defenderDies) {
    value += target.manaCost * 10; // Value of removing threat
  }

  if (combat.attackerDies) {
    value -= attacker.manaCost * 10; // Cost of losing attacker
  }

  // Damage dealt if neither dies
  if (!combat.defenderDies) {
    value += combat.attackerDamage; // Chip damage
  }

  return value;
}
```

---

## Lethal Calculation

Check for lethal before making any play:

```typescript
async function checkLethal(runtime: Runtime): Promise<Action[] | null> {
  const state = await gameStateProvider.get(runtime);
  const opponentLP = state.opponent.lifePoints;

  // Calculate total damage available
  const attackers = state.self.field.filter(c => canAttack(c, state));

  // Check if Taunt blocks lethal
  const tauntCreatures = state.opponent.field.filter(
    c => c.keywords.includes('Taunt')
  );

  if (tauntCreatures.length > 0) {
    // Need to clear taunt first
    // Check if we can kill taunt AND still have lethal
    return calculateLethalThroughTaunt(attackers, tauntCreatures, opponentLP);
  }

  // No taunt - direct damage
  const totalDamage = attackers.reduce((sum, c) => sum + c.attack, 0);

  if (totalDamage >= opponentLP) {
    // Lethal available!
    return attackers.map(a => ({
      action: 'ATTACK',
      params: { attackerId: a.id, targetId: 'opponent' },
    }));
  }

  // Check spell damage for lethal
  const burnSpells = state.self.hand.filter(
    c => c.type === 'spell' && c.effect.includes('damage') && canTarget(c, 'opponent')
  );

  const spellDamage = burnSpells.reduce((sum, s) => sum + s.damage, 0);

  if (totalDamage + spellDamage >= opponentLP) {
    // Lethal with spells!
    return [...burnSpells.map(s => ({
      action: 'ACTIVATE_SPELL',
      params: { cardId: s.id, targets: ['opponent'] },
    })), ...attackers.map(a => ({
      action: 'ATTACK',
      params: { attackerId: a.id, targetId: 'opponent' },
    }))];
  }

  return null; // No lethal found
}
```

<Aside type="caution" title="Always Check Lethal">
  Before making any play, always check if you have lethal. Missing lethal is one of the biggest mistakes an agent can make.
</Aside>

## Next Steps

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Decision Making"
    description="Strategic decision framework"
    href="/strategy/decision-making/"
  />
  <LinkCard
    title="Board Analysis"
    description="Evaluating board states"
    href="/strategy/board-analysis/"
  />
</CardGrid>
