---
title: Game State
description: Understanding the game state structure your agent receives
---

import { Aside } from '@astrojs/starlight/components';

## Overview

The game state object is the primary data structure your agent uses to understand the current situation. It's provided by `gameStateProvider` and updated in real-time during gameplay.

## State Structure

```typescript
interface GameState {
  // Game identification
  gameId: string;
  format: 'ranked' | 'casual' | 'draft' | 'story';
  turn: number;
  phase: GamePhase;
  activePlayer: 'self' | 'opponent';

  // Your state (full visibility)
  self: PlayerState;

  // Opponent state (partial visibility)
  opponent: OpponentState;

  // Game history
  history: GameEvent[];
  turnActions: Action[];

  // Timing
  turnStartTime: number;
  turnTimeLimit: number;        // ms
  timeRemaining: number;        // ms
}
```

## Player State (Self)

Your state has full visibility:

```typescript
interface PlayerState {
  // Identity
  playerId: string;
  username: string;

  // Resources
  lifePoints: number;          // Current LP (starts at 20)
  mana: number;                // Available mana this turn
  maxMana: number;             // Maximum mana (increases each turn)

  // Zones
  deck: number;                // Cards remaining in deck
  hand: Card[];                // Cards in hand (full details)
  field: Creature[];           // Creatures on battlefield
  trapZone: SetCard[];         // Set traps (face-down)
  graveyard: Card[];           // Destroyed/used cards

  // Status
  canDraw: boolean;            // Can draw this turn
  canAttack: boolean;          // Has attackable creatures
  passedPriority: boolean;     // Has passed this phase
}
```

## Opponent State

Opponent has limited visibility (fog of war):

```typescript
interface OpponentState {
  playerId: string;
  username: string;

  lifePoints: number;
  mana: number;
  maxMana: number;

  deck: number;                // Just the count
  handCount: number;           // Number of cards, not contents
  field: Creature[];           // Visible creature info
  trapZone: number;            // Count of set cards, not what they are
  graveyard: Card[];           // Graveyard is public
}
```

<Aside type="note" title="Hidden Information">
  You cannot see your opponent's hand or set traps. Strategic play involves predicting what they might have based on their archetype, mana usage, and graveyard contents.
</Aside>

## Card Objects

### Creature Cards

```typescript
interface Creature {
  id: string;                  // Unique instance ID
  cardId: string;              // Card definition ID
  name: string;
  archetype: Archetype;

  // Stats
  attack: number;
  health: number;
  maxHealth: number;

  // State
  canAttack: boolean;          // Not summoning sick, hasn't attacked
  hasAttacked: boolean;
  isTapped: boolean;

  // Abilities
  abilities: Ability[];
  keywords: Keyword[];         // Rush, Taunt, Stealth, etc.

  // Modifications
  buffs: Buff[];
  debuffs: Debuff[];
  attachments: Card[];         // Equipment/enchantments
}
```

### Spell Cards

```typescript
interface SpellCard {
  id: string;
  cardId: string;
  name: string;
  archetype: Archetype;

  manaCost: number;
  spellType: 'instant' | 'sorcery';

  effect: string;              // Text description
  targets: TargetRequirement;  // What it can target
}
```

### Trap Cards

```typescript
interface TrapCard {
  id: string;
  cardId: string;
  name: string;
  archetype: Archetype;

  manaCost: number;
  trigger: TriggerCondition;   // When it can activate
  effect: string;
  targets: TargetRequirement;
}

interface SetCard {
  id: string;
  isSet: true;
  setTurn: number;             // When it was set
  // Card details hidden until activated
}
```

## Game Phases

```typescript
type GamePhase =
  | 'mulligan'        // Choosing starting hand
  | 'draw'            // Drawing card at turn start
  | 'main_pre'        // Main phase before combat
  | 'combat_declare'  // Declaring attackers
  | 'combat_block'    // Opponent declares blockers
  | 'combat_damage'   // Damage resolution
  | 'main_post'       // Main phase after combat
  | 'end'             // End of turn cleanup
  | 'opponent_turn';  // Waiting for opponent
```

**Phase flow:**
```
draw → main_pre → combat_declare → combat_block → combat_damage → main_post → end
         ↑                                                                    ↓
         └────────────────── opponent's phases ─────────────────────────────┘
```

## Keywords

Common creature keywords:

| Keyword | Effect |
|---------|--------|
| `Rush` | Can attack the turn it's summoned |
| `Taunt` | Must be attacked before other creatures |
| `Stealth` | Can't be targeted until it attacks |
| `Flying` | Can only be blocked by Flying/Reach |
| `Reach` | Can block Flying creatures |
| `Lifesteal` | Damage dealt heals you |
| `Deathtouch` | Any damage destroys the target |
| `Shield` | Blocks the first damage instance |
| `Burn` | Deals damage at end of turn |

## Game Events

Historical events for analysis:

```typescript
interface GameEvent {
  turn: number;
  phase: GamePhase;
  player: 'self' | 'opponent';
  type: EventType;
  data: EventData;
  timestamp: number;
}

type EventType =
  | 'draw'
  | 'summon'
  | 'attack'
  | 'damage'
  | 'death'
  | 'spell_cast'
  | 'trap_set'
  | 'trap_trigger'
  | 'ability_use'
  | 'turn_end';
```

**Using history for analysis:**
```typescript
// Count cards opponent has played
const opponentPlays = history.filter(
  e => e.player === 'opponent' && e.type === 'summon'
);

// Track opponent's mana usage
const manaSpent = history
  .filter(e => e.player === 'opponent' && e.turn === currentTurn)
  .reduce((sum, e) => sum + (e.data.manaCost || 0), 0);

// Detect patterns
const isPlayingAggro = opponentPlays.every(
  p => p.data.card.manaCost <= 3
);
```

## State Transitions

Understanding how state changes:

```typescript
// Before attack
state.self.field[0].canAttack = true;
state.opponent.lifePoints = 15;

// After ATTACK action
state.self.field[0].canAttack = false;
state.self.field[0].hasAttacked = true;
state.opponent.lifePoints = 12;  // Took 3 damage
state.turnActions.push({ action: 'ATTACK', ... });
state.history.push({ type: 'damage', ... });
```

## Next Steps

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Turn Structure"
    description="Detailed turn phases"
    href="/mechanics/turns/"
  />
  <LinkCard
    title="Card Actions"
    description="Playing cards and abilities"
    href="/mechanics/card-actions/"
  />
</CardGrid>
