---
title: Card Actions
description: How to play cards and use abilities
---

import { Aside } from '@astrojs/starlight/components';

## Playing Cards

There are three ways to play cards from your hand: summon creatures, cast spells, and set traps.

### Summoning Creatures

Creatures are your primary way to deal damage and control the board.

**Requirements:**
- Creature card in hand
- Sufficient mana
- Available board space (max 5 creatures)

**Process:**
```typescript
// 1. Check if summon is legal
const legal = await legalActionsProvider.get(runtime);
const summonActions = legal.filter(a => a.action === 'SUMMON_CREATURE');

// 2. Select creature to summon
const creature = summonActions.find(a => a.params.cardId === targetCardId);

// 3. Execute summon
await runtime.executeAction('SUMMON_CREATURE', {
  cardId: creature.params.cardId,
  position: 2,  // Optional: specific board position
});
```

**After summoning:**
- Creature enters the battlefield
- Summoning sickness applies (can't attack this turn unless Rush)
- "When summoned" abilities trigger
- Mana is spent

---

### Casting Spells

Spells provide immediate effects and don't stay on the battlefield.

**Spell types:**

| Type | When castable |
|------|---------------|
| `instant` | Any time (your turn or reaction window) |
| `sorcery` | Only during your main phases |

**Targeting spells:**
```typescript
// Spell that requires a target
await runtime.executeAction('ACTIVATE_SPELL', {
  cardId: 'fireball_001',
  targets: ['enemy_creature_01'],
});

// Spell with multiple targets
await runtime.executeAction('ACTIVATE_SPELL', {
  cardId: 'chain_lightning_001',
  targets: ['creature_01', 'creature_02', 'creature_03'],
});

// Spell with no target (affects all or self)
await runtime.executeAction('ACTIVATE_SPELL', {
  cardId: 'draw_two_001',
});
```

**Target validation:**
```typescript
// Check valid targets before casting
const legal = await legalActionsProvider.get(runtime);
const fireballAction = legal.find(
  a => a.action === 'ACTIVATE_SPELL' && a.params.cardId === 'fireball_001'
);

// fireballAction.params.validTargets contains legal target IDs
const validTargets = fireballAction.params.validTargets;
```

---

### Setting Traps

Traps are placed face-down and activate when conditions are met.

**Setting a trap:**
```typescript
await runtime.executeAction('SET_CARD', {
  cardId: 'mirror_force_001',
  position: 0,  // Trap zone position (0-4)
});
```

**Trap zone rules:**
- Maximum 5 set cards
- Traps can't activate the turn they're set
- Opponent sees you set a card but not what it is

**Activating traps:**
```typescript
// During a reaction window
realtimeService.on('reaction:window', async ({ trigger }) => {
  // Check if any traps can activate
  const state = await gameStateProvider.get(runtime);
  const activatableTraps = state.self.trapZone.filter(trap =>
    trap.trigger === trigger.type && trap.setTurn < state.turn
  );

  if (activatableTraps.length > 0) {
    await runtime.executeAction('ACTIVATE_TRAP', {
      cardId: activatableTraps[0].id,
      targets: selectTargets(trigger),
    });
  }
});
```

<Aside type="tip" title="Trap Timing">
  Traps have specific trigger conditions. A "when attacked" trap can only activate during combat declaration, not during main phase.
</Aside>

---

## Using Abilities

Many creatures have activated abilities that cost resources or have cooldowns.

### Ability Types

| Type | Activation | Cost |
|------|------------|------|
| `activated` | Manual activation | Mana, tap, other |
| `triggered` | Automatic on condition | None |
| `static` | Always active | None |

### Activating Abilities

```typescript
// Use creature's ability
await runtime.executeAction('USE_ABILITY', {
  creatureId: 'my_dragon_01',
  abilityIndex: 0,          // First ability
  targets: ['target_01'],   // If ability requires targeting
});
```

**Checking ability availability:**
```typescript
const state = await gameStateProvider.get(runtime);

for (const creature of state.self.field) {
  for (let i = 0; i < creature.abilities.length; i++) {
    const ability = creature.abilities[i];

    if (ability.type === 'activated') {
      const canUse =
        ability.manaCost <= state.self.mana &&
        !ability.onCooldown &&
        (!ability.tapRequired || !creature.isTapped);

      console.log(`${creature.name} ability ${i}: ${canUse ? 'usable' : 'not usable'}`);
    }
  }
}
```

---

## Card Costs

### Mana Costs

Every card has a mana cost:

```typescript
interface Card {
  manaCost: number;  // 0-10 typically
  // ...
}
```

**Cost modifiers:**
- Some cards reduce costs: "Dragons cost 1 less"
- Some effects increase costs: "Spells cost 2 more this turn"

```typescript
// Get actual cost (with modifiers)
const actualCost = getModifiedCost(card, state);

function getModifiedCost(card: Card, state: GameState): number {
  let cost = card.manaCost;

  // Apply cost reduction effects
  for (const effect of state.self.activeEffects) {
    if (effect.type === 'cost_reduction') {
      if (matchesCondition(card, effect.condition)) {
        cost -= effect.amount;
      }
    }
  }

  return Math.max(0, cost);  // Can't go negative
}
```

### Additional Costs

Some cards have extra costs:

```typescript
interface Card {
  manaCost: number;
  additionalCost?: {
    type: 'sacrifice' | 'discard' | 'life' | 'tap';
    amount: number;
    target?: string;  // For sacrifice: what to sacrifice
  };
}
```

**Example: Sacrifice cost**
```typescript
// Dark Ritual: Sacrifice a creature to gain 3 mana
await runtime.executeAction('ACTIVATE_SPELL', {
  cardId: 'dark_ritual_001',
  sacrificeTarget: 'my_creature_01',
});
```

---

## Card States

Cards can be in various states:

```typescript
interface Creature {
  // Position states
  isTapped: boolean;       // Used this turn
  isFlipped: boolean;      // Face-down
  isAttacking: boolean;    // Declared as attacker
  isBlocking: boolean;     // Declared as blocker

  // Condition states
  hasSummoningSickness: boolean;
  hasAttacked: boolean;
  hasUsedAbility: boolean;

  // Effect states
  isStealthed: boolean;    // Can't be targeted
  isInvulnerable: boolean; // Can't take damage
  isSilenced: boolean;     // Abilities disabled
}
```

---

## Common Patterns

### Efficient Mana Usage

```typescript
async function useAllMana(runtime: Runtime) {
  const state = await gameStateProvider.get(runtime);
  const hand = await handProvider.get(runtime);

  let remainingMana = state.self.mana;
  const toPlay: Card[] = [];

  // Sort by cost descending to use mana efficiently
  const playable = [...hand.playable.now].sort((a, b) => b.manaCost - a.manaCost);

  for (const card of playable) {
    if (card.manaCost <= remainingMana) {
      toPlay.push(card);
      remainingMana -= card.manaCost;
    }
  }

  return toPlay;
}
```

### Spell Timing

```typescript
async function shouldCastNow(spell: Card, state: GameState): boolean {
  // Removal spells: cast when there's a threat
  if (spell.effect.includes('destroy')) {
    const threats = await threatEvaluator.evaluate(runtime, state.opponent.field);
    return threats.some(t => t.level === 'high' || t.level === 'critical');
  }

  // Buff spells: cast before combat
  if (spell.effect.includes('buff') && state.phase === 'main_pre') {
    return state.self.field.length > 0;
  }

  // Draw spells: cast when hand is low
  if (spell.effect.includes('draw')) {
    return state.self.hand.length <= 3;
  }

  return false;
}
```

## Next Steps

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Combat"
    description="Combat mechanics"
    href="/mechanics/combat/"
  />
  <LinkCard
    title="Decision Making"
    description="Strategic decisions"
    href="/strategy/decision-making/"
  />
</CardGrid>
