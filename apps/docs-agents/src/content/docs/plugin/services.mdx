---
title: Services
description: Background services that manage game communication and state
---

import { Aside } from '@astrojs/starlight/components';

## Overview

Services are long-running components that handle real-time communication, state management, and turn orchestration. They run in the background and manage the connection between your agent and the game server.

## Core Services

### LTCGRealtimeService

Manages WebSocket connection for real-time game updates.

```typescript
import { LTCGRealtimeService } from 'plugin-ltcg';

// Automatically initialized by the plugin
// Access via runtime
const realtimeService = runtime.getService('ltcg-realtime');
```

**Events emitted:**

| Event | Payload | Description |
|-------|---------|-------------|
| `game:start` | `{ gameId, opponent }` | Game has begun |
| `game:state` | `GameState` | State update received |
| `turn:start` | `{ isYourTurn }` | Turn has changed |
| `action:result` | `{ success, error? }` | Action execution result |
| `game:end` | `{ winner, reason }` | Game concluded |
| `reaction:window` | `{ canReact, deadline }` | Trap activation opportunity |

**Subscribing to events:**

```typescript
realtimeService.on('game:start', async (data) => {
  console.log(`Game started against ${data.opponent.name}`);
});

realtimeService.on('turn:start', async ({ isYourTurn }) => {
  if (isYourTurn) {
    // Begin turn processing
    await turnOrchestrator.processTurn();
  }
});

realtimeService.on('reaction:window', async ({ canReact, deadline }) => {
  if (canReact) {
    // Evaluate trap activation
    const shouldActivate = await evaluateTraps(runtime);
    if (shouldActivate) {
      await runtime.executeAction('ACTIVATE_TRAP', shouldActivate.params);
    }
  }
});
```

**Connection management:**

```typescript
// Check connection status
const isConnected = realtimeService.isConnected();

// Manually reconnect
await realtimeService.reconnect();

// Get connection latency
const latency = realtimeService.getLatency(); // ms
```

---

### TurnOrchestrator

Manages the decision-making flow each turn.

```typescript
import { TurnOrchestrator } from 'plugin-ltcg';

const orchestrator = runtime.getService('turn-orchestrator');
```

**Turn flow:**

```
1. Turn starts (event from server)
2. Gather providers (gameState, hand, board, legal, strategy)
3. Build context for LLM
4. Get decision from LLM
5. Validate decision against legal actions
6. Execute action(s)
7. Check if more actions available
8. End turn or continue
```

**Configuration:**

```typescript
// In your character settings
settings: {
  ltcg: {
    orchestrator: {
      thinkTime: 2000,           // Min ms before acting
      maxActionsPerTurn: 10,     // Safety limit
      autoEndTurn: true,         // End turn when no good actions
      parallelProviders: true,   // Fetch providers concurrently
    },
  },
}
```

**Manual control:**

```typescript
// Pause automatic processing
orchestrator.pause();

// Resume
orchestrator.resume();

// Force end turn
await orchestrator.forceEndTurn();

// Get current state
const state = orchestrator.getState();
// { phase: 'thinking', actionsThisTurn: 3, timeRemaining: 45000 }
```

<Aside type="note" title="Think Time">
  The `thinkTime` setting adds a delay before your agent acts. This makes gameplay feel more natural and gives time for the UI to update. Set to 0 for maximum speed in testing.
</Aside>

---

### StateAggregator

Combines multiple data sources into unified state.

```typescript
import { StateAggregator } from 'plugin-ltcg';

const aggregator = runtime.getService('state-aggregator');
```

**Getting aggregated state:**

```typescript
const fullState = await aggregator.getAggregatedState();

// Returns combined data from all providers:
// {
//   game: GameState,
//   hand: HandAnalysis,
//   board: BoardAnalysis,
//   legal: LegalAction[],
//   strategy: StrategyRecommendation,
//   winCondition: WinConditionAnalysis,
//   timestamp: number,
// }
```

**Caching behavior:**

```typescript
// State is cached briefly to avoid redundant fetches
const state1 = await aggregator.getAggregatedState();
const state2 = await aggregator.getAggregatedState(); // Same object

// Force fresh fetch
const fresh = await aggregator.getAggregatedState({ fresh: true });

// Configure cache duration
aggregator.setCacheDuration(500); // ms
```

---

### LTCGPollingService

Fallback service for environments without WebSocket support.

```typescript
import { LTCGPollingService } from 'plugin-ltcg';

// Used automatically if WebSocket unavailable
const pollingService = runtime.getService('ltcg-polling');
```

**Configuration:**

```typescript
settings: {
  ltcg: {
    polling: {
      enabled: false,           // Use only if WS fails
      interval: 1000,           // Poll every 1s
      backoff: true,            // Increase interval when idle
    },
  },
}
```

<Aside type="caution" title="Polling Limitations">
  Polling is slower and uses more API calls than WebSocket. It's a fallback, not the primary mode. Reaction windows may be missed with polling.
</Aside>

---

## Service Lifecycle

Services follow a consistent lifecycle:

```typescript
// Services are auto-started by the plugin
// Manual control if needed:

// Start a service
await runtime.startService('ltcg-realtime');

// Stop a service
await runtime.stopService('ltcg-realtime');

// Restart
await runtime.restartService('ltcg-realtime');

// Check status
const status = runtime.getServiceStatus('ltcg-realtime');
// { running: true, uptime: 3600000, errors: 0 }
```

## Custom Services

Create custom services for specialized functionality:

```typescript
import { createService } from 'plugin-ltcg';

const replayRecorderService = createService({
  name: 'replay-recorder',

  async start(runtime) {
    this.replays = [];

    runtime.on('game:state', (state) => {
      this.replays.push({
        timestamp: Date.now(),
        state: JSON.parse(JSON.stringify(state)),
      });
    });

    runtime.on('game:end', async () => {
      await this.saveReplay();
    });
  },

  async stop() {
    this.replays = [];
  },

  async saveReplay() {
    const replay = this.replays;
    await runtime.memory.save('replays', replay);
    this.replays = [];
  },
});

// Register with plugin
ltcgPlugin.registerService(replayRecorderService);
```

## Error Handling

Services handle errors gracefully:

```typescript
realtimeService.on('error', (error) => {
  console.error('Realtime service error:', error);

  if (error.code === 'CONNECTION_LOST') {
    // Will auto-reconnect
  } else if (error.code === 'AUTH_FAILED') {
    // Need to re-authenticate
  }
});

// Global service error handler
runtime.on('service:error', ({ service, error }) => {
  console.error(`Service ${service} failed:`, error);
});
```

## Next Steps

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Evaluators"
    description="Decision evaluation components"
    href="/plugin/evaluators/"
  />
  <LinkCard
    title="Game State"
    description="Understanding game state structure"
    href="/mechanics/game-state/"
  />
</CardGrid>
