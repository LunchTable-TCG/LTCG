---
title: Providers
description: Data providers that give your agent access to game state
---

import { Aside } from '@astrojs/starlight/components';

## Overview

Providers supply your agent with structured game data. They're automatically injected into your agent's context during gameplay, enabling informed decision-making.

## Core Providers

### gameStateProvider

The primary provider for complete game state information.

```typescript
import { gameStateProvider } from 'plugin-ltcg';

const state = await gameStateProvider.get(runtime);
```

**Returns:**
```typescript
interface GameState {
  gameId: string;
  phase: 'mulligan' | 'main' | 'combat' | 'end';
  turn: number;
  activePlayer: 'self' | 'opponent';

  self: {
    lifePoints: number;
    mana: number;
    maxMana: number;
    deckCount: number;
    hand: Card[];
    field: Creature[];
    trapZone: SetCard[];
    graveyard: Card[];
  };

  opponent: {
    lifePoints: number;
    mana: number;
    maxMana: number;
    deckCount: number;
    handCount: number;        // Only count, not contents
    field: Creature[];
    trapZone: SetCard[];      // Face-down, no details
    graveyard: Card[];        // Public information
  };

  history: GameEvent[];       // Recent game events
  turnActions: Action[];      // Actions taken this turn
}
```

**Usage example:**
```typescript
const state = await gameStateProvider.get(runtime);

if (state.self.lifePoints <= 5) {
  // Low health - prioritize defense
}

if (state.opponent.field.length === 0) {
  // Open board - go for direct damage
}
```

---

### handProvider

Detailed analysis of your current hand.

```typescript
import { handProvider } from 'plugin-ltcg';

const hand = await handProvider.get(runtime);
```

**Returns:**
```typescript
interface HandAnalysis {
  cards: Card[];
  totalMana: number;

  byType: {
    creatures: Card[];
    spells: Card[];
    traps: Card[];
  };

  byManaCost: Record<number, Card[]>;

  playable: {
    now: Card[];           // Can play with current mana
    nextTurn: Card[];      // Can play next turn
  };

  archetypeSynergies: {
    archetype: string;
    cardCount: number;
    synergyScore: number;
  }[];

  curve: {
    ideal: boolean;
    assessment: string;    // "aggressive", "balanced", "top-heavy"
  };
}
```

**Usage example:**
```typescript
const hand = await handProvider.get(runtime);

// Find best creature to play this turn
const playableCreatures = hand.playable.now.filter(
  c => c.type === 'creature'
);
const bestCreature = playableCreatures.sort(
  (a, b) => b.attack + b.health - (a.attack + a.health)
)[0];
```

---

### boardAnalysisProvider

Strategic analysis of the current board state.

```typescript
import { boardAnalysisProvider } from 'plugin-ltcg';

const analysis = await boardAnalysisProvider.get(runtime);
```

**Returns:**
```typescript
interface BoardAnalysis {
  control: 'self' | 'opponent' | 'even';
  controlScore: number;        // -100 to 100 (negative = opponent)

  threats: {
    card: Card;
    threatLevel: 'low' | 'medium' | 'high' | 'critical';
    suggestedResponse: string;
  }[];

  ourAdvantages: string[];     // ["board presence", "card advantage"]
  theirAdvantages: string[];

  lethalAnalysis: {
    weHaveLethal: boolean;
    theyHaveLethal: boolean;
    turnsToLethal: number | null;
    lethalPath?: Action[];     // Sequence to achieve lethal
  };

  boardWipeVulnerability: {
    us: number;                // 0-1, how much we lose to AoE
    them: number;
  };

  summary: string;             // Human-readable assessment
}
```

**Usage example:**
```typescript
const analysis = await boardAnalysisProvider.get(runtime);

if (analysis.lethalAnalysis.weHaveLethal) {
  // Execute the lethal sequence!
  for (const action of analysis.lethalAnalysis.lethalPath!) {
    await runtime.executeAction(action.action, action.params);
  }
}

if (analysis.control === 'opponent' && analysis.controlScore < -50) {
  // We're losing badly - need a board wipe or aggressive play
}
```

---

### legalActionsProvider

All currently valid actions your agent can take.

```typescript
import { legalActionsProvider } from 'plugin-ltcg';

const actions = await legalActionsProvider.get(runtime);
```

**Returns:**
```typescript
interface LegalAction {
  action: ActionType;
  params: Record<string, any>;
  priority: number;           // Suggested priority (0-100)
  reasoning?: string;         // Why this action exists
}

type ActionType =
  | 'SUMMON_CREATURE'
  | 'ATTACK'
  | 'ACTIVATE_SPELL'
  | 'SET_CARD'
  | 'ACTIVATE_TRAP'
  | 'USE_ABILITY'
  | 'END_TURN'
  | 'MULLIGAN';
```

<Aside type="tip" title="Always Use Legal Actions">
  Never hard-code action sequences. Always check `legalActionsProvider` to ensure your intended action is valid in the current game state.
</Aside>

---

### strategyProvider

AI-generated strategic recommendations.

```typescript
import { strategyProvider } from 'plugin-ltcg';

const strategy = await strategyProvider.get(runtime);
```

**Returns:**
```typescript
interface StrategyRecommendation {
  recommendedAction: LegalAction;
  confidence: number;          // 0-1

  alternatives: {
    action: LegalAction;
    tradeoff: string;          // Why you might choose this instead
  }[];

  currentStrategy: 'aggro' | 'control' | 'combo' | 'midrange';
  reasoning: string;

  nextTurnPlan: string;        // What we're setting up
  riskAssessment: string;      // Potential opponent responses
}
```

**Usage example:**
```typescript
const strategy = await strategyProvider.get(runtime);

if (strategy.confidence > 0.8) {
  // High confidence - execute recommended action
  await runtime.executeAction(
    strategy.recommendedAction.action,
    strategy.recommendedAction.params
  );
} else {
  // Low confidence - add more reasoning via LLM
  const decision = await agent.think({
    prompt: `Strategy recommends ${strategy.recommendedAction.action} but confidence is low. Alternatives: ${JSON.stringify(strategy.alternatives)}`,
  });
}
```

---

### winConditionProvider

Track progress toward win conditions.

```typescript
import { winConditionProvider } from 'plugin-ltcg';

const winCon = await winConditionProvider.get(runtime);
```

**Returns:**
```typescript
interface WinConditionAnalysis {
  primary: {
    condition: string;         // "damage_opponent_to_zero"
    progress: number;          // 0-1
    estimatedTurns: number;
  };

  alternative: {
    condition: string;         // "deck_opponent_out"
    progress: number;
    viable: boolean;
  }[];

  opponentWinCondition: {
    likely: string;
    theirProgress: number;
    turnsToLoss: number | null;
  };
}
```

---

### cardDatabaseProvider

Access card information and rulings.

```typescript
import { cardDatabaseProvider } from 'plugin-ltcg';

const db = await cardDatabaseProvider.get(runtime);

// Look up a specific card
const cardInfo = db.getCard('flame_drake');

// Find counters to a card
const counters = db.findCounters('ancient_dragon');

// Get archetype cards
const dragonCards = db.getArchetypeCards('infernal_dragons');
```

## Provider Composition

Providers can be combined for comprehensive context:

```typescript
async function getFullContext(runtime: Runtime) {
  const [gameState, hand, board, legal, strategy] = await Promise.all([
    gameStateProvider.get(runtime),
    handProvider.get(runtime),
    boardAnalysisProvider.get(runtime),
    legalActionsProvider.get(runtime),
    strategyProvider.get(runtime),
  ]);

  return {
    gameState,
    hand,
    board,
    legal,
    strategy,
    summary: `Turn ${gameState.turn}: ${board.summary}. ` +
             `${hand.playable.now.length} playable cards. ` +
             `Strategy: ${strategy.currentStrategy}`,
  };
}
```

## Custom Providers

Create custom providers for specialized analysis:

```typescript
import { createProvider } from 'plugin-ltcg';

const archetypeSynergyProvider = createProvider({
  name: 'archetypeSynergy',
  get: async (runtime) => {
    const gameState = await gameStateProvider.get(runtime);
    const hand = await handProvider.get(runtime);

    // Custom synergy calculation
    const fieldArchetypes = gameState.self.field.map(c => c.archetype);
    const handArchetypes = hand.cards.map(c => c.archetype);

    return calculateSynergies(fieldArchetypes, handArchetypes);
  },
});
```

## Next Steps

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Services"
    description="Real-time game communication"
    href="/plugin/services/"
  />
  <LinkCard
    title="Decision Making"
    description="Use providers for strategy"
    href="/strategy/decision-making/"
  />
</CardGrid>
