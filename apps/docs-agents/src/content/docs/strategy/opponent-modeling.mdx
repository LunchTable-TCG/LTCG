---
title: Opponent Modeling
description: Techniques for predicting opponent behavior
---

import { Aside } from '@astrojs/starlight/components';

## Overview

Opponent modeling involves predicting what your opponent might do based on available information. Since you can't see their hand or set traps, you must infer their likely plays.

## Information Sources

### Public Information

What you can observe:

| Information | What it tells you |
|-------------|-------------------|
| Cards played | Their archetype and strategy |
| Graveyard | Cards already used |
| Mana spent | What they could afford |
| Set traps count | Potential responses |
| Hand size | Resources available |
| Play patterns | Skill level, tendencies |

### Hidden Information

What you must infer:

| Information | How to infer |
|-------------|--------------|
| Hand contents | Mana not spent, archetype cards not seen |
| Set trap types | Common traps for their archetype |
| Next plays | Mana curve, board state needs |
| Win condition | Archetype typical win cons |

---

## Archetype Profiling

Build profiles for each archetype:

```typescript
interface ArchetypeProfile {
  archetype: string;
  strategy: 'aggro' | 'midrange' | 'control' | 'combo';
  keyCards: string[];
  commonTraps: string[];
  winCondition: string;
  weaknesses: string[];
  playPattern: string;
}

const ARCHETYPE_PROFILES: Record<string, ArchetypeProfile> = {
  infernal_dragons: {
    archetype: 'infernal_dragons',
    strategy: 'aggro',
    keyCards: ['Flame Drake', 'Inferno Blast', 'Dragon Hatchling', 'Ancient Dragon'],
    commonTraps: ['Scorching Counter', 'Dragon\'s Wrath'],
    winCondition: 'Burn opponent down quickly with direct damage',
    weaknesses: ['Board wipes', 'Healing', 'Taunt walls'],
    playPattern: 'Plays creatures on curve, attacks face, uses burn to finish',
  },

  abyssal_depths: {
    archetype: 'abyssal_depths',
    strategy: 'control',
    keyCards: ['Tidal Wave', 'Kraken', 'Drowning Abyss', 'Sea Serpent'],
    commonTraps: ['Undertow', 'Crushing Depths'],
    winCondition: 'Control board until late game threats take over',
    weaknesses: ['Early aggression', 'Can\'t catch up if behind'],
    playPattern: 'Clears threats, stabilizes, then deploys finishers',
  },

  necro_empire: {
    archetype: 'necro_empire',
    strategy: 'midrange',
    keyCards: ['Skeleton Army', 'Dark Ritual', 'Lich King', 'Raise Dead'],
    commonTraps: ['Death\'s Touch', 'Grave Robber'],
    winCondition: 'Grind out value through recursion',
    weaknesses: ['Graveyard hate', 'Exile effects'],
    playPattern: 'Sacrifices creatures for value, brings them back',
  },

  // ... other archetypes
};
```

---

## Predicting Hands

Estimate what opponent likely holds:

```typescript
interface HandPrediction {
  likelyCards: { card: string; probability: number }[];
  manaRange: { min: number; max: number };
  hasRemoval: number;       // Probability 0-1
  hasCreature: number;
  hasTrap: number;
}

function predictHand(state: GameState): HandPrediction {
  const archetype = identifyOpponentArchetype(state);
  const profile = ARCHETYPE_PROFILES[archetype || 'neutral'];

  const handSize = state.opponent.handCount;
  const manaAvailable = state.opponent.mana;
  const manaNotSpent = state.opponent.maxMana - getManaSpentThisTurn(state);

  // Seen cards reduce pool
  const seenCards = [
    ...state.opponent.field.map(c => c.name),
    ...state.opponent.graveyard.map(c => c.name),
  ];

  // Estimate likely cards based on archetype
  const likelyCards = profile.keyCards
    .filter(card => !seenCards.includes(card) || canHaveMultiple(card))
    .map(card => ({
      card,
      probability: estimateProbability(card, handSize, seenCards),
    }));

  // Estimate card types
  const hasRemoval = profile.strategy === 'control' ? 0.7 : 0.4;
  const hasCreature = handSize >= 3 ? 0.9 : 0.6;
  const hasTrap = state.opponent.trapZone < 3 && manaNotSpent >= 2 ? 0.5 : 0.2;

  return {
    likelyCards,
    manaRange: { min: 0, max: manaAvailable },
    hasRemoval,
    hasCreature,
    hasTrap,
  };
}
```

---

## Predicting Traps

Estimate set trap types:

```typescript
interface TrapPrediction {
  trapType: string;
  probability: number;
  triggerCondition: string;
  counterPlay: string;
}

function predictSetTraps(state: GameState): TrapPrediction[] {
  const archetype = identifyOpponentArchetype(state);
  const profile = ARCHETYPE_PROFILES[archetype || 'neutral'];
  const setCount = state.opponent.trapZone;

  if (setCount === 0) return [];

  // Common traps for their archetype
  const archetypeTraps = profile.commonTraps.map(trap => ({
    trapType: trap,
    probability: 0.4,
    triggerCondition: getTriggerCondition(trap),
    counterPlay: getCounterPlay(trap),
  }));

  // Universal traps anyone might play
  const universalTraps = [
    {
      trapType: 'Mirror Force',
      probability: 0.3,
      triggerCondition: 'When attacked',
      counterPlay: 'Attack with weakest creature first',
    },
    {
      trapType: 'Counterspell',
      probability: 0.25,
      triggerCondition: 'When spell cast',
      counterPlay: 'Bait with low-value spell first',
    },
    {
      trapType: 'Ambush',
      probability: 0.2,
      triggerCondition: 'When creature summoned',
      counterPlay: 'Summon in main phase 2',
    },
  ];

  return [...archetypeTraps, ...universalTraps]
    .sort((a, b) => b.probability - a.probability)
    .slice(0, setCount * 2);
}
```

<Aside type="tip" title="Trap Baiting">
  When you suspect a specific trap, bait it with a less valuable card. Attack with a small creature first to trigger combat traps.
</Aside>

---

## Predicting Next Turn

Anticipate opponent's plays:

```typescript
interface TurnPrediction {
  likelyPlays: {
    action: string;
    target?: string;
    probability: number;
  }[];
  expectedDamage: number;
  threatsDeployed: number;
  manaUsage: number;
}

function predictNextTurn(state: GameState): TurnPrediction {
  const profile = ARCHETYPE_PROFILES[identifyOpponentArchetype(state) || 'neutral'];
  const theirMana = state.opponent.maxMana + 1; // Next turn mana

  const predictions: TurnPrediction['likelyPlays'] = [];

  // Aggro archetypes attack face
  if (profile.strategy === 'aggro') {
    predictions.push({
      action: 'ATTACK_FACE',
      probability: 0.9,
    });
    predictions.push({
      action: 'SUMMON_THREAT',
      probability: 0.8,
    });
  }

  // Control archetypes remove threats
  if (profile.strategy === 'control') {
    if (state.self.field.length > 0) {
      predictions.push({
        action: 'REMOVAL',
        target: getBiggestThreat(state.self.field).id,
        probability: 0.7,
      });
    }
    predictions.push({
      action: 'DEVELOP_BOARD',
      probability: 0.5,
    });
  }

  // Estimate damage
  const expectedDamage = state.opponent.field
    .filter(c => c.canAttack)
    .reduce((sum, c) => sum + c.attack, 0);

  return {
    likelyPlays: predictions,
    expectedDamage,
    threatsDeployed: profile.strategy === 'aggro' ? 1 : 0.5,
    manaUsage: theirMana * 0.8,
  };
}
```

---

## Skill Assessment

Gauge opponent skill level:

```typescript
interface SkillAssessment {
  level: 'beginner' | 'intermediate' | 'advanced' | 'expert';
  indicators: string[];
  adjustments: string[];
}

function assessOpponentSkill(state: GameState): SkillAssessment {
  const history = state.history.filter(e => e.player === 'opponent');
  const indicators: string[] = [];

  let score = 50; // Start neutral

  // Check for efficient mana usage
  const manaEfficiency = history.filter(e =>
    e.type === 'turn_end' && e.data.manaRemaining <= 1
  ).length / (state.turn || 1);

  if (manaEfficiency > 0.7) {
    score += 20;
    indicators.push('Efficient mana usage');
  }

  // Check for favorable trades
  const trades = history.filter(e => e.type === 'attack');
  const favorableTrades = trades.filter(e => e.data.netValue > 0).length;

  if (trades.length > 0 && favorableTrades / trades.length > 0.6) {
    score += 15;
    indicators.push('Makes favorable trades');
  }

  // Check for trap timing
  const trapActivations = history.filter(e => e.type === 'trap_trigger');
  const optimalActivations = trapActivations.filter(e => e.data.optimal).length;

  if (trapActivations.length > 0 && optimalActivations / trapActivations.length > 0.7) {
    score += 15;
    indicators.push('Good trap timing');
  }

  // Determine level
  let level: SkillAssessment['level'];
  if (score >= 80) level = 'expert';
  else if (score >= 65) level = 'advanced';
  else if (score >= 45) level = 'intermediate';
  else level = 'beginner';

  // Adjustments based on skill
  const adjustments: string[] = [];
  if (level === 'expert') {
    adjustments.push('Expect optimal plays');
    adjustments.push('Bluffs may be intentional');
  } else if (level === 'beginner') {
    adjustments.push('May miss lethal');
    adjustments.push('Likely to overextend');
  }

  return { level, indicators, adjustments };
}
```

---

## Incorporating Predictions

Use predictions in decision-making:

```typescript
async function makeInformedDecision(runtime: Runtime): Promise<Action> {
  const state = await gameStateProvider.get(runtime);

  // Get predictions
  const handPrediction = predictHand(state);
  const trapPredictions = predictSetTraps(state);
  const nextTurn = predictNextTurn(state);
  const skill = assessOpponentSkill(state);

  // Adjust strategy based on predictions
  const strategy = await strategyProvider.get(runtime);

  // If they likely have removal, don't commit everything
  if (handPrediction.hasRemoval > 0.6) {
    strategy.adjustRiskTolerance(-0.2);
  }

  // If traps are set, consider baiting
  if (trapPredictions.length > 0) {
    const combatTrap = trapPredictions.find(t =>
      t.triggerCondition.includes('attack')
    );
    if (combatTrap && combatTrap.probability > 0.3) {
      // Attack with smallest creature first
      return createBaitAttack(state);
    }
  }

  // If they're likely to attack next turn, set up defense
  if (nextTurn.expectedDamage > state.self.lifePoints * 0.4) {
    return prioritizeDefense(state);
  }

  return strategy.recommendedAction;
}
```

## Next Steps

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Basic Agent"
    description="Simple agent implementation"
    href="/examples/basic-agent/"
  />
  <LinkCard
    title="Aggressive Agent"
    description="Fast, damage-focused agent"
    href="/examples/aggressive-agent/"
  />
</CardGrid>
