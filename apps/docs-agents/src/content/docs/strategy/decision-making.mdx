---
title: Decision Making
description: Framework for strategic decision-making in your agent
---

import { Aside } from '@astrojs/starlight/components';

## Decision Framework

Every turn, your agent must decide the optimal sequence of actions. This guide provides a framework for making those decisions.

## The Decision Loop

```
┌─────────────────────────────────────────────────────────────────┐
│                     TURN DECISION LOOP                          │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
    ┌─────────┐     Yes    ┌─────────────┐
    │ Lethal? │──────────▶│ Execute Win │
    └─────────┘            └─────────────┘
         │ No
         ▼
    ┌─────────────┐   Yes  ┌─────────────┐
    │ Dying next? │───────▶│ Survive     │
    └─────────────┘        └─────────────┘
         │ No
         ▼
    ┌─────────────┐   Yes  ┌─────────────┐
    │ Must react? │───────▶│ Remove      │
    └─────────────┘        │ Threat      │
         │ No              └─────────────┘
         ▼
    ┌─────────────┐
    │ Advance     │
    │ Game Plan   │
    └─────────────┘
```

## Priority Order

Always evaluate in this order:

### 1. Check for Lethal

**The most important check.** If you can win, win.

```typescript
async function checkLethalFirst(runtime: Runtime): Promise<Action[] | null> {
  const board = await boardAnalysisProvider.get(runtime);

  if (board.lethalAnalysis.weHaveLethal) {
    console.log('[LETHAL] Executing lethal sequence');
    return board.lethalAnalysis.lethalPath;
  }

  return null;
}
```

### 2. Check for Survival

If opponent has lethal, you must prevent it.

```typescript
async function checkSurvival(runtime: Runtime): Promise<Action[] | null> {
  const board = await boardAnalysisProvider.get(runtime);

  if (board.lethalAnalysis.theyHaveLethal) {
    console.log('[SURVIVAL] Opponent has lethal, finding answer');

    // Find removal for their threats
    const removal = await findRemoval(runtime, board.threats);
    if (removal) return removal;

    // Find heal/shield
    const defense = await findDefense(runtime);
    if (defense) return defense;

    // Find taunt to block
    const taunt = await findTaunt(runtime);
    if (taunt) return taunt;

    console.log('[SURVIVAL] No answer found - playing to outs');
  }

  return null;
}
```

### 3. React to Threats

Remove or neutralize significant threats.

```typescript
async function handleThreats(runtime: Runtime): Promise<Action[] | null> {
  const threats = await threatEvaluator.evaluate(runtime);

  const criticalThreats = threats.filter(t => t.level === 'critical');
  const highThreats = threats.filter(t => t.level === 'high');

  for (const threat of [...criticalThreats, ...highThreats]) {
    const answer = await findAnswer(runtime, threat);
    if (answer) {
      console.log(`[THREAT] Handling ${threat.card.name} with ${answer.action}`);
      return [answer];
    }
  }

  return null;
}
```

### 4. Advance Game Plan

Develop your board and work toward your win condition.

```typescript
async function advanceGamePlan(runtime: Runtime): Promise<Action[]> {
  const strategy = await strategyProvider.get(runtime);
  const hand = await handProvider.get(runtime);

  console.log(`[STRATEGY] Current: ${strategy.currentStrategy}`);
  console.log(`[STRATEGY] Recommendation: ${strategy.reasoning}`);

  // Follow strategy recommendations
  return [strategy.recommendedAction];
}
```

---

## Strategy Types

### Aggro Strategy

Goal: Kill opponent as fast as possible.

```typescript
const aggroDecision = async (runtime: Runtime) => {
  // Always attack face if possible
  const state = await gameStateProvider.get(runtime);
  const legal = await legalActionsProvider.get(runtime);

  const attacks = legal
    .filter(a => a.action === 'ATTACK')
    .filter(a => a.params.targetId === 'opponent');

  // Execute all face attacks
  for (const attack of attacks) {
    await runtime.executeAction('ATTACK', attack.params);
  }

  // Then summon more threats
  const summons = legal.filter(a => a.action === 'SUMMON_CREATURE');
  const bestSummon = summons.sort((a, b) =>
    getCreature(b.params.cardId).attack - getCreature(a.params.cardId).attack
  )[0];

  if (bestSummon) {
    await runtime.executeAction('SUMMON_CREATURE', bestSummon.params);
  }
};
```

### Control Strategy

Goal: Answer threats and win in the late game.

```typescript
const controlDecision = async (runtime: Runtime) => {
  const state = await gameStateProvider.get(runtime);
  const threats = await threatEvaluator.evaluate(runtime);

  // Remove the biggest threat
  if (threats.priority) {
    const removal = await findRemoval(runtime, threats.priority);
    if (removal) {
      await runtime.executeAction(removal.action, removal.params);
      return;
    }
  }

  // Develop board with defensive creatures
  const hand = await handProvider.get(runtime);
  const tauntCreatures = hand.cards.filter(
    c => c.type === 'creature' && c.keywords.includes('Taunt')
  );

  if (tauntCreatures.length > 0) {
    await runtime.executeAction('SUMMON_CREATURE', {
      cardId: tauntCreatures[0].id,
    });
  }

  // Set traps
  const traps = hand.cards.filter(c => c.type === 'trap');
  if (traps.length > 0 && state.self.trapZone.length < 3) {
    await runtime.executeAction('SET_CARD', { cardId: traps[0].id });
  }
};
```

### Midrange Strategy

Goal: Flexible play based on board state.

```typescript
const midrangeDecision = async (runtime: Runtime) => {
  const board = await boardAnalysisProvider.get(runtime);

  if (board.control === 'self') {
    // We're ahead - be aggressive
    await aggroDecision(runtime);
  } else if (board.control === 'opponent') {
    // We're behind - be reactive
    await controlDecision(runtime);
  } else {
    // Even - develop efficiently
    await efficientDevelopment(runtime);
  }
};
```

---

## Action Sequencing

Order matters. Execute actions in the optimal sequence:

```typescript
async function executeTurn(runtime: Runtime) {
  // 1. Lethal check (highest priority)
  const lethal = await checkLethalFirst(runtime);
  if (lethal) {
    for (const action of lethal) {
      await runtime.executeAction(action.action, action.params);
    }
    return;
  }

  // 2. Pre-combat spells (buffs, removal)
  await castPreCombatSpells(runtime);

  // 3. Summon Rush creatures
  await summonRushCreatures(runtime);

  // 4. Combat
  await executeCombat(runtime);

  // 5. Post-combat summons
  await summonRemainingCreatures(runtime);

  // 6. Set traps
  await setTraps(runtime);

  // 7. End turn
  await runtime.executeAction('END_TURN', {});
}
```

---

## Mana Management

Efficient mana usage is critical:

```typescript
async function efficientManaUse(runtime: Runtime) {
  const state = await gameStateProvider.get(runtime);
  const hand = await handProvider.get(runtime);

  let mana = state.self.mana;
  const toPlay: Card[] = [];

  // Sort by priority * (mana efficiency)
  const prioritized = hand.playable.now.sort((a, b) => {
    const aValue = getCardValue(a) / a.manaCost;
    const bValue = getCardValue(b) / b.manaCost;
    return bValue - aValue;
  });

  // Fill mana curve
  for (const card of prioritized) {
    if (card.manaCost <= mana) {
      toPlay.push(card);
      mana -= card.manaCost;
    }
  }

  // Consider saving mana for reactions
  const shouldSave = state.self.trapZone.length > 0 ||
                     hand.cards.some(c => c.spellType === 'instant');

  if (shouldSave && mana >= 2) {
    // Keep 2 mana for reactions
    // Remove lowest priority card from toPlay
    toPlay.pop();
  }

  return toPlay;
}
```

---

## Risk Assessment

Evaluate risks before committing:

```typescript
async function assessRisk(action: Action, runtime: Runtime): number {
  const state = await gameStateProvider.get(runtime);

  let risk = 0;

  // Opponent has set cards (potential traps)
  if (state.opponent.trapZone > 0) {
    if (action.action === 'ATTACK') risk += 20;
    if (action.action === 'SUMMON_CREATURE') risk += 10;
  }

  // Committing all resources
  if (action.action === 'SUMMON_CREATURE') {
    const card = getCard(action.params.cardId);
    if (card.manaCost === state.self.mana) {
      risk += 15; // No mana for responses
    }
  }

  // Overextending into board wipe
  if (action.action === 'SUMMON_CREATURE' && state.self.field.length >= 3) {
    risk += 25; // Vulnerable to AoE
  }

  return risk;
}
```

<Aside type="tip" title="Risk Tolerance">
  Adjust risk tolerance based on game state. When losing, take more risks. When winning, play conservatively.
</Aside>

## Next Steps

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
  <LinkCard
    title="Board Analysis"
    description="Deep board evaluation"
    href="/strategy/board-analysis/"
  />
  <LinkCard
    title="Opponent Modeling"
    description="Predict opponent behavior"
    href="/strategy/opponent-modeling/"
  />
</CardGrid>
