---
title: Role-Based Access Control (RBAC)
description: Complete guide to using the RBAC system including role hierarchy, permissions, and usage examples
lastUpdated: '2026-02-03'
tags: ['security', 'rbac', 'authorization', 'permissions', 'admin']
---

This guide explains how to use the comprehensive RBAC system in the LTCG application.

## Overview

The RBAC system provides fine-grained access control with role hierarchy and permission-based authorization. It supports four role levels:

- **User** (level 0): Regular users with no special permissions
- **Moderator** (level 1): Can view reports, analytics, and manage user reports
- **Admin** (level 2): Full user management, shop, economy, and content management
- **Superadmin** (level 3): Complete system access including role management

## Role Hierarchy

### Role Levels

```typescript
{
  user: 0,
  moderator: 1,
  admin: 2,
  superadmin: 3
}
```

Higher-level roles inherit all permissions from lower-level roles.

### Role Management Rules

- **Superadmin** can manage all roles (moderator, admin, superadmin)
- **Admin** can only manage moderator roles
- **Moderator** and **User** cannot manage any roles

## Permission System

### Available Permissions

#### User Management
- `read:users` - View user information
- `write:users` - Modify user data
- `delete:users` - Delete users
- `ban:users` - Ban/unban users

#### Role Management
- `manage:moderators` - Grant/revoke moderator roles
- `manage:admins` - Grant/revoke admin and superadmin roles
- `view:roles` - View role assignments

#### Analytics & Reports
- `view:analytics` - View platform analytics
- `view:reports` - View user reports
- `manage:reports` - Review and resolve reports

#### Economy & Shop
- `manage:shop` - Manage shop products
- `manage:economy` - Control economy settings
- `view:transactions` - View transaction history

#### Content Management
- `manage:cards` - Manage card definitions
- `manage:quests` - Manage quest system
- `manage:achievements` - Manage achievements

#### System Administration
- `manage:system` - System-level configuration
- `view:logs` - View audit logs
- `execute:cleanup` - Run cleanup operations

### Role-to-Permission Mapping

**Moderator:**
- `read:users`
- `view:reports`
- `manage:reports`
- `view:analytics`

**Admin:** (includes all moderator permissions plus)
- `write:users`
- `delete:users`
- `ban:users`
- `manage:moderators`
- `view:roles`
- `manage:shop`
- `manage:economy`
- `view:transactions`
- `manage:cards`
- `manage:quests`
- `manage:achievements`
- `view:logs`

**Superadmin:** (includes all admin permissions plus)
- `manage:admins`
- `manage:system`
- `execute:cleanup`

## Usage Examples

### 1. Require Specific Role Level

Use `requireRole()` when you need a minimum role level:

```typescript
import { requireRole } from "../lib/roles";

export const deleteUserByEmail = mutation({
  args: { email: v.string() },
  handler: async (ctx, args) => {
    const { userId } = await requireAuthMutation(ctx);

    // Require admin role or higher
    await requireRole(ctx, userId, "admin");

    // Your admin logic here...
  },
});
```

### 2. Require Specific Permission

Use `requirePermission()` for granular permission checks:

```typescript
import { requirePermission } from "../lib/roles";

export const manageShop = mutation({
  args: { /* ... */ },
  handler: async (ctx, args) => {
    const { userId } = await requireAuthMutation(ctx);

    // Require specific permission
    await requirePermission(ctx, userId, "manage:shop");

    // Your shop management logic here...
  },
});
```

### 3. Check Permission Without Throwing

Use `checkPermission()` for conditional logic:

```typescript
import { checkPermission } from "../lib/roles";

export const getContent = query({
  args: {},
  handler: async (ctx) => {
    const { userId } = await requireAuthQuery(ctx);

    // Check if user has permission (doesn't throw)
    const canViewAnalytics = await checkPermission(ctx, userId, "view:analytics");

    return {
      content: "...",
      showAnalytics: canViewAnalytics,
    };
  },
});
```

### 4. Grant Role to User

```typescript
import { api } from "../_generated/api";

// Grant moderator role (requires admin)
await ctx.runMutation(api.admin.roles.grantRole, {
  targetUserId: someUserId,
  role: "moderator",
});

// Grant admin role (requires superadmin)
await ctx.runMutation(api.admin.roles.grantRole, {
  targetUserId: someUserId,
  role: "admin",
});
```

### 5. Revoke Role from User

```typescript
import { api } from "../_generated/api";

await ctx.runMutation(api.admin.roles.revokeRole, {
  targetUserId: someUserId,
});
```

### 6. List All Admins

```typescript
import { api } from "../_generated/api";

// Get all admins
const allAdmins = await ctx.runQuery(api.admin.roles.listAdminsByRole, {});

// Get only superadmins
const superadmins = await ctx.runQuery(api.admin.roles.listAdminsByRole, {
  role: "superadmin",
});
```

### 7. Get Current User's Role

```typescript
import { api } from "../_generated/api";

const myRole = await ctx.runQuery(api.admin.roles.getMyRole, {});
console.log(myRole);
// {
//   role: "admin",
//   roleLevel: 2,
//   isAdmin: true,
//   isModerator: true,
//   isFullAdmin: true,
//   isSuperAdmin: false
// }
```

## Best Practices

### 1. Use Role Checks for Coarse Authorization

When you need to restrict entire endpoints to admin levels:

```typescript
// Good: Coarse-grained role check
await requireRole(ctx, userId, "admin");
```

### 2. Use Permission Checks for Fine-Grained Authorization

When specific operations need specific permissions:

```typescript
// Good: Fine-grained permission check
await requirePermission(ctx, userId, "manage:shop");
```

### 3. Log Administrative Actions

Always log sensitive operations:

```typescript
await ctx.scheduler.runAfter(0, internal.lib.adminAudit.logAdminAction, {
  adminId: userId,
  action: "delete_user",
  targetUserId: deletedUserId,
  metadata: { reason: "violation" },
  success: true,
});
```

### 4. Prevent Self-Modification

Prevent users from modifying their own roles:

```typescript
if (targetUserId === userId) {
  throw createError(ErrorCode.VALIDATION_INVALID_INPUT, {
    reason: "Cannot modify your own role",
  });
}
```

### 5. Validate Role Transitions

Ensure role upgrades follow proper hierarchy:

```typescript
const canManage = canManageRole(actorRole, targetRole);
if (!canManage) {
  throw createError(ErrorCode.AUTHZ_INSUFFICIENT_PERMISSIONS);
}
```

## Frontend Integration

### Check User Role in UI

```typescript
import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";

function AdminPanel() {
  const myRole = useQuery(api.admin.roles.getMyRole);

  if (!myRole?.isAdmin) {
    return <div>Access denied</div>;
  }

  return (
    <div>
      {myRole.isModerator && <ModeratorPanel />}
      {myRole.isFullAdmin && <AdminPanel />}
      {myRole.isSuperAdmin && <SuperAdminPanel />}
    </div>
  );
}
```

## Security Considerations

1. **Never expose role management to frontend**: All role grants/revokes should go through protected mutations
2. **Always validate actor permissions**: Check both the actor and target in role management operations
3. **Audit all role changes**: Log every role grant/revoke with who, what, when
4. **Prevent role escalation**: Ensure users cannot grant roles higher than their own
5. **Require authentication**: All admin operations must require auth first

## Troubleshooting

### Error: "Role required but user has insufficient permissions"

Check that the user has an active admin role in the database:

```typescript
const adminRole = await ctx.db
  .query("adminRoles")
  .withIndex("by_user", (q) => q.eq("userId", userId))
  .filter((q) => q.eq(q.field("isActive"), true))
  .first();
```

### Error: "Cannot grant role with current role"

Verify the actor has sufficient permissions to grant the target role:

```typescript
const canManage = canManageRole(actorRole, targetRole);
// superadmin can manage all, admin can manage moderator
```

## Related Documentation

- [Authentication Security](/reference/security/authentication) - Auth security measures
- [Testing Strategy](/develop/testing-strategy) - Testing admin operations
